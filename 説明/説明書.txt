■背景
RuneScape というゲームでは自分が操作するプレイヤーを敵と戦わせ、その敵を倒すことができる。
敵を倒すには用意されている様々な「アビリティ」を用いる。
（「ability_icons」ディレクトリ内のディレクトリにアビリティのアイコンが多数格納されているので、それを見るとイメージしやすいかもしれない。）

全てのアビリティには「強さ」と「待ち時間」が定義されており、強いアビリティほど「待ち時間」は長い。
（強さとは、そのアビリティが敵に与えるダメージの期待値である。
待ち時間とは「１回発動してから次に発動可能になるまでの時間」のことである。
例えばアビリティAの待ち時間が３秒の場合、アビリティA発動後に３秒待たないとアビリティAは再発動できない。）
ただし「強さ」と「待ち時間」は比例しない。
また、特定アビリティを強化するアビリティも存在する。
つまりアビリティの発動順序を最適化し、与ダメージ量を最大化するためには経験と知識を持ったうえで、アビリティを手動で発動する必要がある。

アビリティは手動で発動することもできるが、自動的に発動させることもできる。
自動的にアビリティを発動するための準備は、アビリティを「アビリティバー」内に任意の順序に並べ、「自動モード」に切り替えるだけである。
準備完了後に敵と戦うと、アビリティがアビリティバーの先頭から発動されていく。

「自動モード」は便利だが、手動に比べて柔軟な対応ができないほか、与ダメージ量も少ないという欠点がある。


■目的
自動モードを使う上で、与ダメージ量が比較的多いアビリティ順序はネットに出回っている。
しかし自動モードの場合はアビリティの発動パターンは１通りであるため、特定の敵に対しては最適のアビリティ順序が存在するはずである。
そこで当プログラムでは自分が操作するプレイヤーの強さと敵の強さを指定し、
その場合に「自動モード」で戦った際の与ダメージ量が最大となるアビリティ順序を求める。
つまり指定場面でのアビリティ順序最適化プログラムである。


■方法
大まかな流れは以下の通りである。
１．プレイヤーや敵などに関するパラメータを指定
２．アビリティバーに追加したいアビリティＡ個を決定
３．上記で決定したアビリティを並び変えて得られるアビリティバー全て（A!通り）に対して指定時間分のシミュレーションを行い、その間の総与ダメージ量Dを算出
４．Dが大きかった上位いくつかのアビリティバーを記録する
５．最大のDのアビリティバーとそのシミュレーション結果をグラフとして出力する

このようにして最強のアビリティバーを求める。
シミュレーション結果のグラフとは縦軸がダメージ、横軸が経過時間のグラフであり、横軸の下にはその時発動したアビリティが表示されている。
このグラフによりシミュレーションの様子を伺うことができる。（ダメージ量が低くい状態が何秒続くかなど重要な情報が得られる）


■工夫した点
・シミュレーションの高速化
アビリティバーには最大１４個のアビリティが入る。
しかしシミュレーションはA！回行うため、１４個アビリティが入ったアビリティバーのシミュレーションをするには計算効率を高める必要がある。
以下の方法を用いて計算時間を当初の約１５倍速くなった。
└アルゴリズムの整理
└ランダム値を期待値に置き換え
└Cライブラリの活用
└行列の利用
└マルチプロセス化
それでも１４アビリティ計算するには以上131年かかることが分かったため、
断念して１０アビリティでシミュレーションを行った。（それでも丸２日計算に時間がかかった）

・グラフとしての出力
アビリティバーだけを出力するのではなく、
ダメージ量と経過時間・発動したアビリティの関係を示すグラフを出力したことで
面白い知見が得られた。
ライブラリ「plotly」を使用。


■結果
ダメージ量上位１０個のアビリティバーを記録した。
それらの間ではあまり差はなかったが、最強のアビリティバーを使って想定していたモンスターを倒したところ、負けてしまった。
手動で倒すのも難しい敵だったため、仕方ないだろう。
敵の攻撃パターンなどをより適切にモデル化することでより良い結果は得られるかもしれない。


■変更できる設定と変数
・バーに含めるアビリティの種類
・何番目のアビリティ配列まで記録するか
・何秒間分のシミュレーションを実行するか
・プレイヤーの強さ、装備など
・敵の強さ、数など

